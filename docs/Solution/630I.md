# I. Parking Lot - 题解

### 比赛与标签
> **比赛**: Experimental Educational Round: VolBIT Formulas Blitz
> **标签**: combinatorics, math
> **难度**: *1700

## 题目大意喵~
主人你好呀~ 这道题是关于一个停车场排列的问题哦！

想象一下，有一个超级大的停车场，它排成了一条长长的直线，一共有 `2n - 2` 个停车位。现在有四种不同品牌的车车（比如 Aston Martin, Bentley, Maybach, Zaporozhets，好酷的名字！）可以停进来。

这个公司的CEO有个小小的强迫症，他希望停车场里**有且仅有**一段连续 `n` 辆相同品牌的车。也就是说，不能有 `n+1` 辆或更多连续相同的车，也不能有多段长度为 `n` 的同品牌车队。

我们的任务就是，计算一下有多少种不同的停车方案，可以满足CEO这个奇特的审美要求呐？

**输入**:
- 一个整数 `n` (3 ≤ n ≤ 30)。

**输出**:
- 一个整数，表示满足条件的总方案数。

## 解题思路，开始分析咯！
这道题看起来有点复杂，但别怕，让本喵带你一步一步拆解它，其实就是一道有趣的组合数学题~ 喵呜~

我们的目标是计算满足“恰好有n辆连续同品牌车”的方案数。我们可以按照下面的步骤来思考：

#### 第一步：选定主角车队！
首先，我们要确定这个长度为 `n` 的连续车队是用哪种品牌的车组成的。我们有4种品牌可以选择，所以这里有 **4** 种选择。我们可以先计算出某一种品牌（比如A品牌）的方案数，最后再乘以4，就是最终答案啦。

#### 第二步：为主角车队找个好位置！
停车场总共有 `2n - 2` 个位置。一个长度为 `n` 的车队，可以放置的起始位置有多少种呢？
它可以从位置1开始，最晚可以从位置 `(2n - 2) - n + 1 = n - 1` 开始。所以，总共有 `n - 1` 个不同的起始位置可以放这个车队。

#### 第三步：最关键的分类讨论呐！
“恰好”是这道题的关键词！这意味着，这个长度为 `n` 的车队旁边，不能再停相同品牌的车了。根据车队摆放位置的不同，对旁边车辆的限制也不同。所以我们要分情况讨论~

我们假设主角车队是A品牌（`A...A`）。

**情况一：车队停在停车场的两端**

这包括车队从位置1开始，或者从位置 `n-1` 开始（这样车队刚好在末尾）。一共有 **2** 个这样的位置。

- 如果车队在最左边，那么排列看起来是 `[A...A][X]...`。
- 为了保证A车队长度恰好是 `n`，第 `n+1` 个位置的车 `X` **不能**是A品牌。所以 `X` 只有3种选择（B, C, D）。
- 剩下的 `(2n - 2) - n - 1 = n - 3` 个车位就可以随便停啦，每个位置都有4种选择。
- 所以，对于停在最左边的情况，方案数是 `3 * 4^(n-3)`。
- 因为左右两端是对称的，所以车队停在两端的总方案数（对于A品牌）是 `2 * 3 * 4^(n-3)`。

**情况二：车队停在中间**

如果车队不是停在两端，那么它的两边都会有其他车位。
- 这样的位置有多少个呢？总共有 `n-1` 个起始位置，去掉两端的2个，还剩下 `(n-1) - 2 = n-3` 个中间位置。
- 排列看起来是 `...[X][A...A][Y]...`。
- 为了保证A车队长度恰好是 `n`，它左右两边的车 `X` 和 `Y` 都**不能**是A品牌。所以 `X` 有3种选择，`Y` 也有3种选择。
- 剩下的 `(2n - 2) - n - 2 = n - 4` 个车位就可以随便停啦，每个位置都有4种选择。
- 所以，对于每一个中间位置，方案数是 `3 * 3 * 4^(n-4) = 9 * 4^(n-4)`。
- 因为有 `n-3` 个这样的中间位置，所以这部分的总方案数（对于A品牌）是 `(n - 3) * 9 * 4^(n-4)`。

#### 第四步：把所有情况加起来喵！

现在，我们把单个品牌（比如A品牌）的所有方案数加起来：
总方案数（单品牌） = (情况一) + (情况二)
= `(2 * 3 * 4^(n-3)) + ((n - 3) * 9 * 4^(n-4))`
= `6 * 4^(n-3) + (n - 3) * 9 * 4^(n-4)`

为了方便计算，我们把它们的幂次统一一下。我们知道 `4^(n-3) = 4 * 4^(n-4)`。
= `6 * 4 * 4^(n-4) + (n - 3) * 9 * 4^(n-4)`
= `24 * 4^(n-4) + (9n - 27) * 4^(n-4)`
= `(24 + 9n - 27) * 4^(n-4)`
= `(9n - 3) * 4^(n-4)`
= `3 * (3n - 1) * 4^(n-4)`

#### 第五步：别忘了乘以4哦！

最后一步，我们有4种品牌可以选择作为主角车队，所以要把上面算出的单品牌方案数乘以4。
最终总方案数 = `4 * [3 * (3n - 1) * 4^(n-4)]`
= `12 * (3n - 1) * 4^(n-4)`

这个公式也可以写成 `3 * (3n - 1) * 4^(n-3)`，这和AC代码里的公式是一样的！推导成功，太棒啦！

## 代码实现喵~
```cpp
#include <iostream>
using namespace std;

int main() {
    int n;
    // 读取题目要求的连续车辆数 n
    cin >> n;

    // 计算 4 的 (n-3) 次方
    // 我们的公式是 3 * (3n - 1) * 4^(n-3)
    // 4^(n-3) = (2^2)^(n-3) = 2^(2*(n-3))
    // 使用位运算 1LL << x 来计算 2^x，效率很高喵~
    // 1LL 是为了保证整个计算过程使用 long long 类型，防止结果太大溢出
    long long power = 1LL << (2 * (n - 3));

    // 根据我们推导出的公式计算最终答案
    // ans = 3 * (3n - 1) * power
    // 这里的 3LL 和 (3LL * n - 1) 也是为了确保使用 long long 进行计算
    long long ans = (3LL * n - 1) * 3 * power;

    // 输出最终的方案数
    cout << ans << endl;
    
    return 0;
}
```

## 复杂度分析
- **时间复杂度**: O(1) 的说。程序只进行几次简单的数学运算，无论`n`是多大，计算的步骤都是固定的，所以是常数时间复杂度，超快的喵~
- **空间复杂度**: O(1) 的说。我们只用了几个变量来存储输入`n`和中间结果`power`、`ans`，没有使用随`n`增大的额外空间。

## 知识点与总结
这道题虽然看起来只是个简单的数学题，但里面包含了不少小知识点和解题思想哦！

1.  **组合数学思想**: 解决这类计数问题的核心思想就是“分步”和“分类”。我们先选择品牌（分步），再根据车队位置（分类）进行讨论，最后把所有情况汇总。这是组合数学最基础也最重要的方法！
2.  **“恰好”问题的处理**: 题目中的 "exactly n" 是一个经典陷阱。处理这类问题时，一定要仔细考虑边界条件，确保不会多数（比如包含了`n+1`个连续的情况）也不会漏数。我们通过限制相邻车辆的品牌来完美解决这个问题。
3.  **数据类型的重要性**: 当`n`最大为30时，`4^(30-3) = 4^27` 是一个非常非常大的数字，会超出普通`int`的范围。所以在编程时，一定要记得使用 `long long` 来存储结果，避免溢出导致WA。代码中的 `1LL` 和 `3LL` 就是这个作用，是C++中一个非常好的习惯！
4.  **位运算技巧**: 使用 `1LL << (2 * (n - 3))` 来计算 `4^(n-3)` 是一个非常聪明且高效的方法。这比使用`pow()`函数更快，也更精确（`pow()`返回`double`，可能存在精度问题）。

希望这篇题解能帮助到你，喵~ 如果还有其他问题，随时可以来问我哦！一起加油，攻克更多有趣的题目吧！