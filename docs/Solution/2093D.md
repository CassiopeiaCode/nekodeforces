喵~ 主人，今天我们来一起看看这道有趣的填表问题呀！它就像一个巨大的、一层套一层的猫抓板，只要找到了规律，挠起来就特别顺手呢！

### 题目大意

这道题是关于一个特殊的数字填充游戏，喵~

我们有一个大小为 $2^n \times 2^n$ 的巨大方格。我们要从 1 开始，按照一个奇特的规则把数字 $1, 2, 3, \dots, 2^{2n}$ 填进去。

规则是这样哒：

1.  **基本单元 (2x2):** 对于一个 $2 \times 2$ 的小方格，我们按下面的顺序填入数字 1, 2, 3, 4：
    *   左上角填 1
    *   右下角填 2
    *   左下角填 3
    *   右上角填 4

    ```
    1 4
    3 2
    ```

2.  **递归填充:** 对于一个更大的 $2^k \times 2^k$ 的方格，我们把它平均分成四个 $2^{k-1} \times 2^{k-1}$ 的子方格。然后，我们按照上面 $2 \times 2$ 的顺序来决定填充这些子方格的顺序：
    *   **第一步：** 递归地填充**左上角**的子方格。
    *   **第二步：** 递归地填充**右下角**的子方格。
    *   **第三步：** 递归地填充**左下角**的子方格。
    *   **第四步：** 递归地填充**右上角**的子方格。

这个过程会一直持续下去，直到我们把整个 $2^n \times 2^n$ 的大方格都填满。

主人你的任务就是回答两种类型的提问：
*   `-> x y`：查询第 `x` 行第 `y` 列的数字是多少。
*   `<- d`：查询数字 `d` 被填在了第几行第几列。

### 题解方法

这个问题看起来很复杂，但其实它有一个非常优美的分形结构，就像猫猫的肉垫一样，放大看还是小肉垫的组合，嘿嘿~ 这种自相似的特性最适合用递归或者迭代的方式来解决啦。

我们可以把整个过程想象成从最大的 $2^n \times 2^n$ 方格开始，一步步缩小范围，直到定位到最终的单元格。

#### 1. 根据坐标 `(x, y)` 求数字 `d`

我们从最大的方格开始，一层一层地往下看。在第 `k` 层（$k$ 从 `n` 到 1），我们处理的是一个 $2^k \times 2^k$ 的问题。

1.  首先判断当前坐标 `(x, y)` 在当前 $2^k \times 2^k$ 方格的哪个象限（左上、右下、左下、右上）。
2.  根据所在的象限，我们就可以确定这个数字所在的大致范围。
    *   如果在**左上**象限，说明它是这个区域里最先被填充的，它的值相对较小。
    *   如果在**右下**象限，说明它在第二批被填充，它的值需要加上第一个象限所有数字的数量。
    *   如果在**左下**象限，说明它在第三批被填充，它的值需要加上前两个象限所有数字的数量。
    *   如果在**右上**象限，说明它在最后一批被填充，它的值需要加上前三个象限所有数字的数量。
3.  一个 $2^{k-1} \times 2^{k-1}$ 的象限里有 $(2^{k-1})^2 = 4^{k-1}$ 个数字。所以我们根据象限给结果加上 $0, 1, 2, 3$ 乘以 $4^{k-1}$ 的偏移量。
4.  然后，我们将坐标 `(x, y)` 更新为它在当前象限内的相对坐标，进入下一层更小的方格继续这个过程。

把每一层计算出的偏移量累加起来，最后就能得到最终的数字啦！

#### 2. 根据数字 `d` 求坐标 `(x, y)`

这个过程正好是反过来的，喵~ 就像看着猫粮袋子上的成分表，反推出猫粮是怎么做出来的一样！

1.  我们同样从第 `k` 层（$k$ 从 `n` 到 1）开始。
2.  用当前的数字 `d` 去除以一个象限的大小（$4^{k-1}$），商就是它所在象限的编号（0, 1, 2, 3）。
    *   商为 0：在**左上**象限。
    *   商为 1：在**右下**象限。
    *   商为 2：在**左下**象限。
    *   商为 3：在**右上**象限。
3.  根据这个象限编号，我们就能确定当前坐标 `(x, y)` 在这一层应该加上怎样的偏移量。
    *   左上：坐标不变。
    *   右下：`x` 和 `y` 都加上当前象限的边长 $2^{k-1}$。
    *   左下：只有 `x` 加上边长。
    *   右上：只有 `y` 加上边长。
4.  然后，我们把数字 `d` 更新为它对 $4^{k-1}$ 的余数，这个余数就是它在那个小象限里的相对编号，用于下一层的计算。

把每一层计算出的坐标偏移量累加起来，就得到了最终的坐标 `(x, y)`。

### 题解

好啦，让本喵带你一步步把代码看懂吧！为了计算方便，我们通常会把 1-indexed 的坐标和数字转换成 0-indexed 来处理，这样位运算和取模会更自然哦。

#### 查询坐标 `(x, y)` 对应的数字

```cpp
// n: 描述表格大小为 2^n x 2^n
// x, y: 1-indexed 的坐标
void solve_find_number(int n, long long x, long long y) {
    long long ans = 0;
    long long r = x - 1, c = y - 1; // 使用 0-indexed 坐标 r, c

    // 从最大尺度 k=n 迭代到最小尺度 k=1
    for (int k = n; k >= 1; --k) {
        long long half = 1LL << (k - 1);         // 当前象限的边长
        long long quad_size = 1LL << (2 * (k - 1)); // 当前象限的格子总数

        bool r_in_upper_half = (r < half);
        bool c_in_left_half = (c < half);

        if (r_in_upper_half && c_in_left_half) { // 1. 左上象限 (编号 0)
            // 啥也不用做，ans 不增加，r,c 也不用变
        } else if (!r_in_upper_half && !c_in_left_half) { // 2. 右下象限 (编号 1)
            ans += quad_size; // 加上第一象限的总数
            r -= half;        // 更新为相对坐标
            c -= half;
        } else if (!r_in_upper_half && c_in_left_half) { // 3. 左下象限 (编号 2)
            ans += 2 * quad_size; // 加上前两个象限的总数
            r -= half;
        } else { // 4. 右上象限 (编号 3)
            ans += 3 * quad_size; // 加上前三个象限的总数
            c -= half;
        }
    }
    std::cout << ans + 1 << "\n"; // 输出 1-indexed 的数字
}
```

这段代码完美地实现了我们刚才的思路。循环从 `n` 到 1，`k` 代表了当前处理的方格级别。`half` 是当前级别下子象限的边长，`quad_size` 是子象限的格子数量。通过判断 `(r, c)` 和 `half` 的关系，确定象限，然后累加 `ans` 并更新 `r, c` 为相对坐标，为下一轮迭代做准备。

#### 查询数字 `d` 对应的坐标

```cpp
// n: 描述表格大小为 2^n x 2^n
// d: 1-indexed 的数字
void solve_find_coords(int n, long long d) {
    long long val = d - 1; // 使用 0-indexed 数字
    long long r = 0, c = 0; // 从 (0,0) 开始构建 0-indexed 坐标

    // 从最大尺度 k=n 迭代到最小尺度 k=1
    for (int k = n; k >= 1; --k) {
        long long half = 1LL << (k - 1);
        long long quad_size = 1LL << (2 * (k - 1));

        // 确定 val 落在哪个象限
        long long quad_idx = val / quad_size;
        // 更新 val 为在当前象限内的相对值
        val %= quad_size;

        if (quad_idx == 0) { // 1. 左上象限
            // r, c 无需增加偏移
        } else if (quad_idx == 1) { // 2. 右下象限
            r += half;
            c += half;
        } else if (quad_idx == 2) { // 3. 左下象限
            r += half;
        } else { // 4. 右上象限 (quad_idx == 3)
            c += half;
        }
    }
    std::cout << r + 1 << " " << c + 1 << "\n"; // 输出 1-indexed 的坐标
}
```
这个函数是逆过程。`quad_idx = val / quad_size` 直接告诉我们数字 `val` 在当前尺度的哪个象限。根据 `quad_idx`，我们给最终坐标 `r, c` 加上相应的偏移量 `half`。然后 `val %= quad_size` 使得 `val` 变成相对于这个象限的值，用于下一轮更精细的定位。

### 知识点介绍

喵哈哈，这道题背后其实藏着一些非常酷的数学和计算机知识呢！

#### 1. 分形 (Fractals) 与递归 (Recursion)

这个表格的填充方式是一个典型的**分形**结构。无论你把这个表格放大多少倍，它的局部结构和整体结构都是相似的。这种“自相似性”是分形最迷人的地方。

在编程中，处理分形结构最自然的思想就是**递归**。一个大问题可以分解成若干个与自身结构相同的子问题。这道题的解法虽然是迭代（`for`循环），但其内在逻辑就是模拟了递归的层层深入。

#### 2. 四进制数 (Quaternary Number System)

这道题的本质，其实是一个坐标和数字之间的**四进制**转换游戏！

*   **数字 -> 坐标**：
    我们可以把一个 0-indexed 的数字 `val` 看作一个 `n` 位的**四进制数** `(d_{n-1} d_{n-2} ... d_0)_4`。
    *   最高位 `d_{n-1}` 决定了它在最大方格的哪个象限。
    *   次高位 `d_{n-2}` 决定了它在次一级方格的哪个象限。
    *   ...
    *   最低位 `d_0` 决定了它在最基础的 $2 \times 2$ 方格的哪个位置。
    我们的 `solve_find_coords` 函数里，`val / quad_size` 就是在取四进制数的最高位，而 `val %= quad_size` 就是在移除最高位。

*   **坐标 -> 数字**：
    反过来，一个 0-indexed 的坐标 `(r, c)` 可以看成两个 `n` 位的**二进制数**，`r = (r_{n-1} ... r_0)_2` 和 `c = (c_{n-1} ... c_0)_2`。
    *   在第 `k` 层，坐标 `(r, c)` 在哪个象限，是由 `r` 和 `c` 的第 `k-1` 位比特 `(r_{k-1}, c_{k-1})` 决定的。
    *   根据题目的填充顺序（左上(0,0), 右下(1,1), 左下(1,0), 右上(0,1)），我们可以建立一个比特对到四进制数位的映射。
    *   `solve_find_number` 函数里的 `if-else` 判断，其实就是在根据坐标的二进制位，逐位构建出数字的四进制表示。

这种将多维坐标映射到一维数字的技术，在数据库和图形学中很有用，通常被称为**空间填充曲线 (Space-filling Curve)**。我们这里的填充顺序（左上-右下-左下-右上）是一种特殊的U型曲线。最常见的另一种是Z阶曲线（Morton Code），它的填充顺序是左上-右上-左下-右下。

理解了这一点，是不是感觉这道题瞬间变得高大上起来了呀？喵~ 希望我的讲解对主人有帮助哦！