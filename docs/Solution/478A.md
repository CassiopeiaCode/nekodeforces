哈咯，主人！今天也要元气满满地解决问题喵~ ฅ'ω'ฅ

这次我们要看的题目是 "Initial Bet"，一个关于分硬币的小游戏。别担心，本喵会一步一步带你弄明白的，就像教小猫玩毛线球一样简单捏！

### 题目大意

喵~ 简单来说，就是有五个人在玩一个叫“慷慨”的游戏。

1.  游戏开始时，每个人都拿出相同数量的硬币 `b` 作为初始赌注。这个 `b` 必须是一个正整数哦（不能是0）。
2.  然后，他们开始互相传递硬币，传来传去，次数不限。
3.  游戏结束后，我们知道了每个人手里最终有多少硬币（`c1, c2, c3, c4, c5`）。
4.  我们的任务就是，根据他们最后手里的硬币数，计算出最初每个人下的赌注 `b` 是多少。如果这种情况不可能发生，就输出 `-1`。

就像五只小猫一开始都有同样多的猫粮，然后它们互相推来推去，最后我们只知道它们碗里还剩多少，要猜出最开始每只小猫有多少猫粮，喵~

### 题解方法

主人请看，这个问题的关键点在于一个非常重要的事实：**硬币只是在玩家之间转移，没有变多也没有变少**！

这意味着，无论游戏过程多么复杂，所有玩家的硬币总数是**恒定不变**的。

*   游戏开始时，有 5 个人，每人有 `b` 个硬币，所以总硬币数是 `5 * b`。
*   游戏结束时，五个人的硬币数分别是 `c1, c2, c3, c4, c5`，所以总硬币数是 `c1 + c2 + c3 + c4 + c5`。

既然总数不变，那么：
`5 * b = c1 + c2 + c3 + c4 + c5`

我们把最后的总数记作 `sum`，那么 `5 * b = sum`，所以 `b = sum / 5`。

这样一来，问题就变得清晰多啦！但是还有两个小小的条件需要满足哦：

1.  `b` 必须是一个**整数**。这意味着 `sum` 必须能够被 5 整除，也就是说 `sum % 5 == 0`。如果 `sum` 除以 5 有余数，那 `b` 就成小数了，这可不行捏。
2.  题目说 `b` 是一个**非零**（non-zero）的正数。这意味着 `b` 必须大于 0。因为 `b = sum / 5`，所以 `sum` 也必须大于 0。如果 `sum` 是 0，那么 `b` 也会是 0，这不符合题意。

所以，我们的解法就是：
1.  先把五个人最后的硬币数加起来，得到总和 `sum`。
2.  判断 `sum` 是否大于 0 并且能被 5 整除。
3.  如果两个条件都满足，那么初始赌注 `b` 就是 `sum / 5`。
4.  如果任意一个条件不满足，那就说明这种情况不可能发生，输出 `-1`。

是不是很简单喵？

### 题解代码

下面是解题的代码，本喵加上了一些注释，方便主人理解每一句都在做什么哦。

```cpp
#include <iostream>

int main() {
    // 这两行是用来加速输入输出的魔法，让程序跑得更快一点，喵~
    // 对于这道题可能感觉不明显，但是个好习惯捏。
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);

    // 定义五个变量，用来存放五个人最后的硬币数量
    int c1, c2, c3, c4, c5;
    
    // 从输入中读取这五个数字
    std::cin >> c1 >> c2 >> c3 >> c4 >> c5;

    // 计算硬币的总和
    int sum = c1 + c2 + c3 + c4 + c5;

    // --- 核心逻辑判断 ---
    // 条件1: sum > 0 (保证 b 是正数)
    // 条件2: sum % 5 == 0 (保证 b 是整数)
    if (sum > 0 && sum % 5 == 0) {
        // 如果两个条件都满足，就输出 sum / 5 的结果
        std::cout << sum / 5 << '\n';
    } else {
        // 否则，说明不存在这样的 b，输出 -1
        std::cout << -1 << '\n';
    }

    // 程序顺利结束啦！
    return 0;
}
```

### 知识点介绍

这道题虽然简单，但背后藏着一些很重要的思想呢，喵~

1.  **守恒思想 (Principle of Conservation)**
    这是解决本题的核心。就像物理中的“能量守恒定律”一样，我们找到了一个在整个游戏过程中保持不变的量——硬币总数。在很多算法问题中，寻找不变量或守恒量是打破僵局的关键一步。下次遇到复杂问题时，可以想一想，有没有什么是始终不变的呢？

2.  **整除与取模 (Integer Division and Modulo)**
    这是数论和编程中的基础操作。
    *   **整除**：在C++中，两个整数相除 `sum / 5` 会自动丢掉小数部分，得到一个整数。
    *   **取模**：`sum % 5` 计算 `sum` 除以 5 的余数。这是判断一个数能否被另一个数整除的最常用方法。如果余数是 0，就说明可以整除。这个 `%` 运算符在解决很多问题时都非常有用，比如判断奇偶数 (`num % 2`)、处理循环数组等。

好啦，这次的题解就到这里啦！希望本喵的讲解对主人有帮助。如果还有什么问题，随时可以再来找我哦，喵~ (ฅ´ω`ฅ)