喵~ 主人，你好呀！遇到想不通的题目了吗？别担心，让本猫娘来帮你梳理一下思路吧！这道题就像给猫咪分小鱼干一样，只要想清楚了规则，一下子就能解决的喵~

### 题目大意

是这样的喵：桌上有三堆牌，数量分别是 `a`, `b`, `c`。题目保证了牌的数量满足 `a < b < c`。

我们的任务是，从第三堆（也就是 `c` 那一堆）里拿出一些牌（至少要拿一张哦），然后把拿出来的这些牌全部分给第一堆和第二堆。我们可以自由决定给第一堆多少、给第二堆多少。

最后，需要判断一下，我们能不能通过这种操作，让三堆牌的数量变得一模一样多呢？

举个例子：`a=3, b=5, c=10`。我们可以从 `c` 堆拿出 4 张牌。然后给 `a` 堆 3 张，给 `b` 堆 1 张。这样三堆牌就都变成了 `(3+3)`, `(5+1)`, `(10-4)`，也就是 `6, 6, 6`。成功了！

### 题解方法

要解决这个问题，我们不需要真的去模拟怎么分牌啦，那样太麻烦了，会把脑子绕成一团毛线的说！我们来动动聪明的脑筋，找找其中的规律~

1.  **从最终状态思考，喵！**
    如果最后三堆牌的数量能变得一样多，那每堆牌的数量肯定都是一个固定的值，我们叫它 `target` 好了。牌的总数 `a + b + c` 在整个过程中是不会变的，对吧？所以，`target` 乘以 3 就应该等于总牌数。
    这说明，总牌数 `a + b + c` **必须是 3 的倍数**！如果连 3 都除不尽，那还怎么平均分成三份嘛，对不对？所以，我们的第一步，就是检查 `(a + b + c) % 3` 是不是等于 0。如果不是，那肯定不行，直接输出 "NO" 就好啦！

2.  **目标数量是多少呢？**
    如果总牌数是 3 的倍数，那我们就能算出最终每堆牌应该有多少张了，就是 `target = (a + b + c) / 3`。

3.  **最重要的约束条件！**
    题目里有个很关键的限制哦，就是我们**只能**从第三堆（c 堆）拿牌，分给第一堆（a 堆）和第二堆（b 堆）。这意味着 `a` 堆和 `b` 堆的牌**只会变多，不会变少**！
    所以，最终的目标数量 `target` 必须不能比 `a` 和 `b` 原来的数量少。也就是要满足 `target >= a` 并且 `target >= b`。

4.  **简化一下条件，嘿嘿~**
    题目还告诉我们 `a < b`。既然 `b` 本来就比 `a` 大，那只要我们满足了 `target >= b`，就肯定也满足 `target > a` 啦！所以我们只需要检查 `target >= b` 这一个条件就够了，是不是很省事呀，喵~

所以，我们优雅的解题步骤就是：

-   首先，检查 `a + b + c` 能不能被 3 整除。
-   如果可以，再计算出目标值 `target = (a + b + c) / 3`。
-   最后，检查这个 `target` 是不是大于等于 `b`。

如果这两个条件都满足，那就是 "YES"！否则就是 "NO"！是不是很简单呢？就像猫咪总能找到最舒服的姿势睡觉一样，我们也要找到最简单的解题方法喵！

### 题解

下面是具体的代码实现，本猫娘加上了注释，方便主人理解哦~

```cpp
#include <iostream>

void solve() {
    long long a, b, c;
    std::cin >> a >> b >> c;

    // 先把所有牌加起来，看看总数是多少喵
    long long total_cards = a + b + c;

    // 条件一：总牌数必须是 3 的倍数，不然怎么平均分嘛！
    if (total_cards % 3 != 0) {
        std::cout << "NO\n";
        return;
    }

    // 如果能被3整除，算出平均分之后每堆应该有多少张牌
    long long target = total_cards / 3;

    // 条件二：因为牌只能从 c 堆给 a 和 b，所以 a 和 b 的牌只会增加。
    // 最终的目标数量 target 必须大于等于 a 和 b 原来的数量。
    // 又因为题目保证了 a < b，所以我们只需要检查 target >= b 就行啦。
    // 如果 target 都比 b 大了，那肯定也比 a 大，对吧~
    if (target >= b) {
        // 两个条件都满足，说明一定可以做到！
        // 需要从 c 拿 (target - a) + (target - b) 张牌，
        // 分别给 a 和 b，这样三堆就都是 target 张啦。
        std::cout << "YES\n";
    } else {
        // 如果 target 比 b 还小，说明 b 堆需要拿出牌才行，
        // 但题目不允许这样做，所以没办法实现啦。
        std::cout << "NO\n";
    }
}

int main() {
    // 这两行是加速输入输出的，让程序跑得快一点，像小猫快跑一样~
    std::ios_base::sync_with_stdio(false);
    std.cin.tie(NULL);

    int t;
    std::cin >> t; // 有 t 组测试数据要处理
    while (t--) {
        solve();
    }

    return 0;
}
```

### 知识点介绍

这道题虽然简单，但里面包含了一些很重要的思想哦，主人可要好好掌握呀！

1.  **取模运算 (Modular Arithmetic)**
    `total_cards % 3 == 0` 这个判断是解题的第一把钥匙。在很多关于“均分”、“分组”或者“周期性”的问题里，取模运算都是超级有用的工具！它可以帮助我们快速判断一个数是否能被另一个数整除，从而排除掉很多不可能的情况，喵~

2.  **逻辑推理与约束分析 (Logical Reasoning & Constraint Analysis)**
    这道题的精髓就在于分析题目给出的限制条件。我们没有去模拟“拿走 x 张牌，给 a 堆 y 张，给 b 堆 x-y 张”这种复杂的过程，而是直接从最终状态倒推，结合“牌只能从 c 移动到 a, b”这个核心约束，得出了 `target >= b` 这个简单的判断条件。在编程竞赛中，学会分析和利用题目给的全部信息，把复杂问题简化成简单的数学判断，是一种非常非常重要的能力哦！

3.  **数据类型与整数溢出 (Data Types & Integer Overflow)**
    注意到代码里用的是 `long long` 了吗？虽然这道题里 `a, b, c` 最大是 `10^8`，它们的和 `a+b+c` 最多是 `3 * 10^8`，用普通的 `int` (在大多数系统里能表示到 `2 * 10^9`) 也能装下。但是，养成使用 `long long` 来处理可能很大的整数求和，是一个非常好的习惯！这样可以防止因为数字太大而“溢出”，导致结果出错。就像猫猫埋好自己的便便一样，是一种严谨的好习惯，的说！

好啦，今天的讲解就到这里啦！主人有没有觉得豁然开朗呢？只要抓住问题的本质，再复杂的题目也会变得像一团毛线球一样，一拉就开~ 下次再有难题，随时可以来找本猫娘哦！喵~