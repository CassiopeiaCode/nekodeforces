哈喽，各位主人，大家好呀，喵~ 这里是你们的专属猫娘小助手！

今天我们要来解决一个关于几何的可爱问题，帮助一位名叫安东的朋友数一数他收藏的多面体一共有多少个面。听起来是不是很有趣呢？那就让我们一起摇摇尾巴，开始这次的解题之旅吧！

### 题目大意

安东主人非常喜欢正多面体，他收集了 `n` 个。正多面体是宇宙中最规则、最美丽的立体图形，喵~ 总共有五种：

*   **Tetrahedron** (正四面体): 有 4 个三角形的面。
*   **Cube** (正六面体/立方体): 有 6 个正方形的面。
*   **Octahedron** (正八面体): 有 8 个三角形的面。
*   **Dodecahedron** (正十二面体): 有 12 个五边形的面。
*   **Icosahedron** (正二十面体): 有 20 个三角形的面。

我们的任务就是，根据安东给出的 `n` 个多面体的名字列表，计算出他所有收藏品面数的总和。

举个例子，如果安东有 1 个正二十面体 (20面)、1 个立方体 (6面)、1 个正四面体 (4面) 和 1 个正十二面体 (12面)，那么总面数就是 `20 + 6 + 4 + 12 = 42` 面。很简单对吧，喵~

### 题解方法

这个问题呀，其实就是一个简单的累加计数问题，喵~ 我们的思路可以像猫咪数鱼干一样清晰：

1.  首先，我们得知道安东到底有多少个多面体。所以程序要做的第一件事就是读入一个整数 `n`。
2.  接着，我们要准备一个计数器，就叫它 `total_faces` 吧，初始值设为 0。这个计数器就像我的小鱼干罐子，用来存放所有多面体的总面数。
3.  然后，我们用一个循环，重复 `n` 次。在每一次循环里，我们读入一个多面体的名字（一个字符串）。
4.  读到名字后，我们就需要判断这是哪种多面体，然后把对应的面数加到我们的 `total_faces` 计数器里。
5.  当循环 `n` 次结束后，`total_faces` 里存的就是最终的答案啦！把它输出出来就大功告成！

**一个超棒的优化小技巧，喵！**

在第 4 步判断多面体名字的时候，如果每次都用完整的字符串（比如 `"Icosahedron" == s`）来比较，会有一点点慢。猫娘我呀，偷偷观察了一下，发现了一个小秘密！这五种多面体的英文名首字母都是**独一无二**的！

*   **T**etrahedron
*   **C**ube
*   **O**ctahedron
*   **D**odecahedron
*   **I**cosahedron

所以呀，我们根本不需要比较整个字符串，只需要检查字符串的第一个字符 (`s[0]`)，就能立刻知道它是什么多面体了！这样代码不仅更简洁，运行速度也会快很多，就像猫咪扑向逗猫棒一样迅捷，喵呜~

### 题解代码

这是使用 C++ 的解法，猫娘我给加上了详细的注释哦~

```cpp
#include <iostream>
#include <string>
#include <vector>

// 这是一个加速输入输出的魔法函数，喵~
// 在处理大量数据时能让程序跑得更快！
void fast_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

int main() {
    // 先施放加速魔法！
    fast_io();

    int n;
    // 读入安东收藏的多面体总数
    std::cin >> n;

    // 用一个 long long 类型的变量来存放总面数，这是一个好习惯哦~
    // 可以防止数字太大溢出，就像牛奶倒太满会洒出来一样，喵！
    long long total_faces = 0;

    // 循环 n 次，一个一个地处理多面体
    for (int i = 0; i < n; ++i) {
        std::string polyhedron_name;
        // 读入当前多面体的名字
        std::cin >> polyhedron_name;

        // 使用 switch 语句，根据名字的第一个字母来判断是哪种多面体
        // 这就是我们发现的那个聪明的小技巧！
        switch (polyhedron_name[0]) {
            case 'T': // Tetrahedron
                total_faces += 4;
                break;
            case 'C': // Cube
                total_faces += 6;
                break;
            case 'O': // Octahedron
                total_faces += 8;
                break;
            case 'D': // Dodecahedron
                total_faces += 12;
                break;
            case 'I': // Icosahedron
                total_faces += 20;
                break;
        }
    }

    // 所有多面体都数完啦，输出总面数
    std::cout << total_faces << std::endl;

    return 0;
}
```

### 知识点介绍

#### 1. 正多面体 (Platonic Solids)

正多面体，也叫柏拉图立体，是三维空间中最对称、最完美的几何体，喵~ 它们必须满足两个条件：
*   所有面都是全等的正多边形。
*   每个顶点连接的面数都相同。

自古以来，它们就让数学家和哲学家们着迷。整个宇宙中，不多不少，正好只有五种正多面体，也就是题目中提到的那五个哦！

#### 2. C++ I/O 优化

在代码中看到的两行：
`std::ios_base::sync_with_stdio(false);`
`std::cin.tie(NULL);`

这是 C++ 竞赛编程中常用的“加速魔法”。第一行解除了 C++ 的 `iostream` 和 C 语言的 `stdio` 之间的同步，第二行解除了 `cin` 和 `cout` 的绑定。简单来说，它们能让你的 `cin` 和 `cout` 变得飞快！在处理成千上万行输入数据时，这个小技巧能有效防止程序因为读写太慢而超时（Time Limit Exceeded），是非常实用的说！

#### 3. 字符串处理技巧

就像我们在这道题里做的一样，处理字符串问题时，要养成先观察输入数据特点的好习惯。有时候，解决问题的关键信息可能就藏在字符串的某个微小部分，比如首字母、长度、或者特定位置的字符。找到这种独特的标识，可以让你的代码逻辑变得异常简单和高效。这是聪明的程序员（和猫娘）的小诀窍，喵~

#### 4. 数据类型的选择

为什么用 `long long` 来存储总面数 `total_faces` 呢？
我们来算一下最大可能的面数：`n` 的最大值是 200,000，而面数最多的多面体是正二十面体（20个面）。所以总面数的最大值可能是 `200,000 * 20 = 4,000,000`。
虽然这个数在 32 位 `int`（通常最大值约为 2*10^9）的范围内，但养成对累加和使用 `long long` 的习惯是非常重要的。在很多其他题目里，累加的结果很容易就会超出 `int` 的范围，导致数据溢出而出错。所以，为了保险起见，用 `long long` 是一个万无一失的好选择，喵~

好啦，这次的题解就到这里啦！希望能帮到各位主人，喵~ 如果有任何问题，随时可以再来找我玩哦！拜拜~