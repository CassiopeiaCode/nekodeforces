喵~ 主人，你好呀！Manao 遇到了一个棘手的锁，不过别担心，有本喵在，再难的问题也能迎刃而解！我们一起来看看这个有趣的按钮问题吧，嘻嘻~ (ฅ'ω'ฅ)

### 题目大意

这道题是说，有一个神奇的锁，上面有 `n` 个按钮。要打开这个锁，需要按下一个特定顺序的按钮序列。

这个锁的机制是这样哒：
- 如果你按下的按钮是序列中下一个正确的按钮，那么这个按钮就会保持按下的状态，喵~
- 如果你按错了，那么**所有**已经按下的按钮都会弹回原位，呜...一切都要重来。
- 当所有 `n` 个按钮都成功地被按下时，锁就打开啦！

Manao 虽然不知道正确的顺序是什么，但他非常聪明，会采用最优的策略。我们需要计算的是，在**最坏的情况**下，Manao 总共需要按多少次按钮才能打开锁。

举个栗子，`n=3`，假设正确顺序是 `{2, 3, 1}`：
1.  **目标：找到第1个按钮。**
    - 如果先按 `1` 或 `3`，它们是错的，按钮会立刻弹起来。
    - 如果先按 `2`，它是对的，按钮 `2` 会保持按下。
2.  **目标：找到第2个按钮（已知第1个是`2`）。**
    - 如果在 `2` 之后按 `1`，`1` 是错的，那么 `2` 和 `1` 都会弹起来。
    - 如果在 `2` 之后按 `3`，`3` 是对的，那么 `2` 和 `3` 都会保持按下。
3.  **目标：找到第3个按钮（已知前两个是`2, 3`）。**
    - 这时候只剩下按钮 `1` 啦，按下它，锁就开啦！

“最坏情况” 指的是，Manao 每次猜测，正确答案总是他尝试的最后一个选项。

### 题解方法

要解决这个问题，我们可以一步一步地分析 Manao 的策略，喵~ 他会一个一个地去确定序列中的按钮。

我们把问题分解成 `n` 个阶段：找到第 1 个正确按钮，找到第 2 个，...，直到找到第 `n` 个。

**阶段一：找到第 1 个正确按钮**

- 这时候一个按钮都还没按下去。有 `n` 个按钮可以选。
- 最坏情况下，Manao 会试遍所有 `n-1` 个错误的按钮，最后才找到那个正确的。
- 每次尝试（无论对错）都只按 1 次。
- 所以，失败的尝试有 `n-1` 次，成功的尝试有 1 次。
- 总共需要按 `(n-1) + 1 = n` 次。

**阶段二：找到第 2 个正确按钮**

- 现在，Manao 已经知道了第 1 个正确的按钮。
- 剩下 `n-1` 个按钮作为第 2 个按钮的候选。其中，`n-2` 个是错的，1 个是对的。
- 为了测试一个候选按钮，Manao 必须先按下第 1 个正确的按钮，再按那个候选按钮。所以，**每一次尝试都需要按 2 次**。
- 在最坏的情况下，他会把 `n-2` 个错误的候选按钮都试一遍。
- 失败的尝试会花费：`(n-2) * 2` 次按键。
- 最后一次成功的尝试：按下第 1 个，再按下第 2 个（正确的），花费 2 次按键。
- 总共需要按 `(n-2) * 2 + 2 = (n-1) * 2` 次。

**阶段 `i`：找到第 `i` 个正确按钮**

- 到了这个阶段，Manao 已经知道了前 `i-1` 个正确的按钮。
- 剩下 `n - (i-1)` 个按钮作为第 `i` 个按钮的候选。其中，`n-i` 个是错的，1 个是对的。
- 为了测试一个候选按钮，他必须先按顺序按下前 `i-1` 个正确的按钮，再按那个候选按钮。所以，**每一次尝试都需要按 `i` 次**。
- 在最坏的情况下，他会把 `n-i` 个错误的候选按钮都试一遍。
- 失败的尝试会花费：`(n-i) * i` 次按键。
- 最后一次成功的尝试：按顺序按下前 `i-1` 个，再按下第 `i` 个（正确的），花费 `i` 次按键。
- 在这个阶段总共需要按 `(n-i) * i + i = (n-i+1) * i` 次。

**总次数**

把每个阶段的按键次数加起来，就是最终答案啦！
总次数 = `Sum_{i=1 to n} [(n-i+1) * i]`

我们可以换个角度来思考，这也是代码里的实现方式，可能会更清晰哦！

总按键次数 = **所有失败尝试的按键数** + **所有成功按键数**

- **所有成功按-键数**：最终，为了打开锁，Manao 需要成功地按下一遍正确的序列，比如 `{B1, B2, ..., Bn}`。这包括：按下 B1（成功），按下 B2（成功），...，按下 Bn（成功）。总共是 `n` 次成功的按键。
- **所有失败尝试的按键数**：
  - 在寻找第 `i` 个按钮时（已知前 `i-1` 个），有 `n-i` 个错误选项。
  - 每次错误的尝试都需要按 `i` 次键（`i-1` 个已知正确的 + 1 个错误的）。
  - 所以在第 `i` 阶段，失败的按键数是 `(n-i) * i`。
- 把所有阶段的失败次数加起来：`Sum_{i=1 to n} [(n-i) * i]`。

所以，总次数 = `n + Sum_{i=1 to n} [(n-i) * i]`。

这个公式和我们上面推导的 `Sum_{i=1 to n} [(n-i+1) * i]` 其实是等价的，喵~
`Sum[(n-i+1) * i] = Sum[(n-i)*i + i] = Sum[(n-i)*i] + Sum[i]`。
咦？好像不对... 让我再挠挠头...

啊！本喵想明白了！上面的逻辑都对，但是加和的方式有点绕。我们直接看代码的逻辑，它把每次成功的**那一下**分开计算了。

在第 `i` 阶段：
1.  有 `n-i` 次失败的尝试，每次尝试花费 `i` 次按键。总计 `(n-i) * i` 次。
2.  有 1 次成功的尝试，但我们只计算让第 `i` 个按钮**最终**留在按下状态的那 1 次按键。
所以，第 `i` 阶段的贡献是 `(n-i) * i` 次（因失败而重复按下的键）+ `1` 次（第 `i` 个按钮被成功按下的那一下）。

所以总次数 = `Sum_{i=1 to n} [ (n-i)*i + 1 ]`。
让我们用 `n=3` 验证一下：
- i=1: `(3-1)*1 + 1 = 3`
- i=2: `(3-2)*2 + 1 = 3`
- i=3: `(3-3)*3 + 1 = 1`
总和 = `3 + 3 + 1 = 7`。和示例输出一样！完美，喵~ (´｡• ᵕ •｡`) ♡

### 题解

这是 C++ 的实现代码，本喵加了一些注释，方便主人理解哦。

```cpp
#include <iostream>

int main() {
    // 使用快速 I/O，这是一个好习惯哦，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(nullptr);

    int n;
    std::cin >> n;

    // 结果可能会很大，所以用 long long 来存答案，防止溢出
    long long total_pushes = 0;

    // 我们从 i=1 到 n 遍历，计算确定序列中每个位置的按钮所需的按键次数
    // i 代表我们正在尝试确定第 i 个按钮
    for (int i = 1; i <= n; ++i) {
        // --- 计算在第 i 阶段因失败尝试而产生的按键次数 ---
        // 在这个阶段，我们已经知道了前 i-1 个按钮。
        // 还有 n-(i-1) 个按钮未知，其中 n-i 个是错误的。
        // 在最坏情况下，我们会把这 n-i 个错误按钮都试一遍。
        // 每一次尝试（先按 i-1 个已知按钮，再按 1 个猜测按钮）都需要按 i 次。
        // 所以失败尝试的总按键数是 (n - i) * i
        long long pushes_for_failures = (long long)(n - i) * i;

        // --- 计算成功按下的那一下 ---
        // 不管失败了多少次，最终我们总要成功地按下第 i 个按钮。
        // 这一下成功的按键贡献了 1 次。
        long long push_for_success = 1;

        // 把这个阶段的按键次数加到总数里
        total_pushes += pushes_for_failures + push_for_success;
    }

    std::cout << total_pushes << std::endl;

    return 0;
}
```

### 知识点介绍

这个问题虽然看起来简单，但背后也藏着一些有趣的知识点呢！

1.  **最坏情况分析 (Worst-Case Analysis)**
    这是算法分析中一个非常核心的概念。我们不是计算平均情况，而是要找到一个上界，保证无论输入（在这里是按钮的正确顺序）是什么，算法的成本（按键次数）都不会超过这个值。在这里，“最坏情况”就是运气最差，每次都最后才猜对。

2.  **构造法/贪心思想 (Constructive/Greedy Approach)**
    我们的解法是一步步构造出来的。在每个阶段，我们都只考虑当前这一步的最优策略（或者说，计算当前这一步的最坏情况），然后把所有步骤的成本累加起来，得到最终的解。这种分步解决问题的思想非常常用。

3.  **求和公式 (Summation Formulas) (进阶知识点)**
    我们的答案是 `Sum_{i=1 to n} [ (n-i)*i + 1 ]`。学过数学的同学可能会发现，这个求和式可以被化简成一个没有循环的数学公式哦！
    
    `Total = Sum_{i=1 to n} [ (n-i)*i + 1 ]`
    `= (Sum_{i=1 to n} 1) + Sum_{i=1 to n} (ni - i^2)`
    `= n + n * Sum_{i=1 to n} i - Sum_{i=1 to n} i^2`
    
    我们知道两个著名的求和公式：
    - `Sum_{i=1 to n} i = n(n+1)/2`
    - `Sum_{i=1 to n} i^2 = n(n+1)(2n+1)/6`
    
    代入进去化简一下，就能得到一个 `O(1)` 的解法：
    `Total = n + n * [n(n+1)/2] - [n(n+1)(2n+1)/6]`
    化简后可以得到 `(n^3 + 5n) / 6`。
    
    用这个公式，即使 `n` 很大，也能瞬间算出答案，是不是很酷，喵~ 不过在比赛中，如果数据范围不大（比如这题的 `n <= 2000`），用循环来写会更直观，也不容易出错。

好啦，这次的题解就到这里啦！希望本喵的讲解对主人有帮助！如果还有其他问题，随时可以再来找我哦~ 喵~ ( >ω<)ﾉ