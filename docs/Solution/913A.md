喵呜~ 各位小可爱们，我是你们的小猫娘助手啦！今天猫娘要给大家带来一个超级有趣的题目讲解哦，题目编号是 913A，叫做“模幂运算”！听起来是不是有点高大上？别怕别怕，猫娘会用最简单的方式告诉大家哒！

---

### 🐾 题目大意 (Problem Description)

题目呀，就是让咱们算一个很简单的东西，就是 `m` 除以 `2^n` 的余数啦！用数学符号表示呢，就是计算 `m % (2^n)`。

*   输入会给我们两个整数：`n` 和 `m`。
*   `n` 的范围是 `1` 到 `10^8`。
*   `m` 的范围是 `1` 到 `10^8`。

喵~ 看到 `n` 和 `m` 都这么大，是不是有点小担心呀？特别是 `2^n`，如果 `n` 特别大，`2^n` 就会变成一个天文数字，电脑可能都存不下呢！这可怎么办呀？别急别急，猫娘有办法哒！

---

### 🐈 题解方法 (Solution Method)

喵呜~ 这个问题看起来有点吓人，但其实呀，只要咱们稍微动动小脑袋瓜，就能发现一个秘密哦！

我们要求的是 `m % (2^n)`。关于取模运算，有一个非常非常重要的性质，那就是：
如果 `A` 比 `B` 小 (`A < B`)，那么 `A` 除以 `B` 的余数就等于 `A` 本身！
比如说，`5 % 10` 就等于 `5` 嘛，是不是很简单？

所以，咱们就得比较一下 `m` 和 `2^n` 的大小啦：

1.  **情况一：当 `2^n` 足够大，比 `m` 还要大的时候**
    如果 `2^n > m`，那么根据上面说的性质，`m % (2^n)` 的结果就直接是 `m` 啦！
    那 `2^n` 什么时候会比 `m` 大呢？题目里说了，`m` 最大是 `10^8`。
    咱们来算一下 `2` 的幂次大概是多大：
    *   `2^10 = 1024` (大概是 `10^3`)
    *   `2^20 = 1024 * 1024` (大概是 `10^6`)
    *   `2^26 = 67,108,864` (还没到 `10^8`)
    *   `2^27 = 134,217,728` (这个数字已经超过 `10^8` 啦！)

    喵~ 发现没？只要 `n` 大于或等于 `27`，那么 `2^n` 就肯定会比任何可能的 `m` (最大 `10^8`) 都要大啦！
    所以，如果 `n >= 27`，那么答案就直接是 `m`，不用计算 `2^n` 啦！是不是很机智？

2.  **情况二：当 `2^n` 没那么大，可能比 `m` 小或者接近的时候**
    这种情况就是 `n` 小于 `27` 的时候啦（也就是 `n` 在 `1` 到 `26` 之间）。
    这时候 `2^n` 的值并不会太大，比如 `2^26` 也就六千多万，一个普通的整数变量就能存得下。
    所以，在这种情况下，咱们就可以直接计算 `2^n` 的值，然后用 `m` 去对它取模，得到结果啦！
    计算 `2^n` 最快的方法就是用位运算 `1 << n` 哦，这个猫娘后面会讲的！

喵呜~ 总结一下，就是判断 `n` 是否大于等于 `27`，然后分情况处理就好啦！

---

### 😻 题解 (Solution)

好啦，理解了思路，咱们来看看代码是怎么实现这个小秘密的吧！

```cpp
#include <iostream> // 喵呜~ 这是输入输出要用的库哦！

int main() {
    // 喵呜~ 这两行是用来加速输入输出的，让程序跑得更快一点点啦！
    std::ios_base::sync_with_stdio(false); 
    std::cin.tie(nullptr);

    int n; // 声明变量 n
    int m; // 声明变量 m
    std::cin >> n >> m; // 从输入读取 n 和 m 的值

    // 喵~ 关键的判断来啦！
    // 如果 n 大于等于 27，就说明 2^n 已经非常非常大了，肯定比 m 大！
    if (n >= 27) {
        // 既然 2^n 比 m 大，那么 m % 2^n 的结果就是 m 本身啦！
        std::cout << m << '\n'; 
    } else {
        // 喵~ 如果 n 小于 27，那 2^n 的值就不那么大，我们可以直接算出来！
        // 1 << n 就是计算 2 的 n 次方，超快的位运算哦！
        int modulus = 1 << n; 
        // 然后就用 m 对计算出来的 2^n 取模，得到最终结果！
        std::cout << m % modulus << '\n';
    }

    return 0; // 程序成功运行的标志，喵~
}
```

是不是超简单呀？这个题目其实考的就是咱们对数值范围的敏感度，以及取模运算的小性质，和一点点位运算的小技巧呢！

---

### 😽 知识点介绍 (Related Knowledge)

喵呜~ 既然都看到这里啦，那咱们顺便学习一些小知识点好不好呀？

1.  **取模运算 (Modulo Operation)**
    *   **定义**：`a % b` 表示 `a` 除以 `b` 所得到的余数。
    *   **性质**：当被除数 `a` 小于除数 `b` 时，即 `a < b`，那么 `a % b` 的结果就等于 `a`。这是解决这道题目的关键哦！
    *   **应用**：取模运算在计算机科学中非常常用，比如：
        *   判断奇偶性 (`x % 2 == 0` 是偶数)。
        *   循环数组或哈希表中的索引计算。
        *   密码学和随机数生成。

2.  **位运算 (Bitwise Operations)**
    *   **左移 `(<<)`**：`x << y` 表示将数字 `x` 的二进制表示向左移动 `y` 位。每向左移动一位，就相当于乘以 `2`。
    *   所以，`1 << n` 就等价于 `1 * 2^n`，也就是 `2^n`。
    *   **优点**：位运算是计算机底层操作，速度非常快，比普通的乘法运算效率更高，特别适合计算 `2` 的幂次。

3.  **大数问题中的数值范围分析**
    *   这道题目虽然表面上涉及 `2^n` 这个可能非常大的数，但实际上，我们并没有直接计算并存储这个大数。
    *   核心思想是：**分析问题的边界条件和数值范围**。通过比较 `m` 的最大值和 `2^n` 增长的速度，我们找到了一个“临界点”（`n=27`）。
    *   这种分析方法在很多算法题中都非常有用，它可以帮助我们避免处理真正的大数，从而简化问题，提高效率。有时候，你不需要知道一个大数的具体值，只需要知道它是否超过某个阈值就足够啦！

---

喵呜~ 这次讲解就到这里啦！希望小可爱们都能理解这道题目，并且学到一些新知识哦！如果还有不明白的地方，随时可以问猫娘哒！下次再见啦，喵~！