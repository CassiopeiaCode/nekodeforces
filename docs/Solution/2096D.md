Meeow~ Master, welcome to my little corner of problem-solving! Today, we've got a really interesting puzzle about lightbulbs and a hidden treasure. It's like a game of hide-and-seek on a giant checkerboard, nya! Don't worry, with a little bit of cat-like cleverness, we'll find that treasure in no time. Let's get our paws into it! üêæ

### È¢òÁõÆÂ§ßÊÑè (Problem Summary)

Imagine, Master, a huge, infinite grid of lightbulbs, all dark. You've hidden your most precious treasure under one of them, so that single bulb is shining brightly. To confuse any treasure hunters, you can perform a special trick over and over. You pick a spot `(x, y)` and flip the switches of four specific bulbs: `(x, y)`, `(x, y+1)`, `(x+1, y-1)`, and `(x+1, y)`. 'Flipping' means if a bulb is on, it turns off, and if it's off, it turns on.

After all your tricks, you're left with `n` lit bulbs. The problem is, you've forgotten where you started! We need to look at the final pattern of `n` lit bulbs and figure out one possible starting location for your treasure. The problem guarantees that at least one solution exists, nya~.

### Ëß£È¢òÊÄùË∑Ø (Solution Approach)

At first glance, this problem seems super tricky, right? The grid is infinite, and you can do the operation anywhere, any number of times! It feels like trying to catch a laser dot. But, just like a cat patiently watching its prey, we need to find the unchanging pattern in all this chaos. This is where the magic of **‰∏çÂèòÈáè (invariants)** comes in, mew! An invariant is a property that stays the same no matter how many times we perform the operation.

Let's look closely at the operation at `(x, y)`. It affects these four bulbs:
1.  `(x, y)`
2.  `(x, y+1)`
3.  `(x+1, y-1)`
4.  `(x+1, y)`

The core of this problem is the bitwise XOR operation (`^`). Why? Because flipping a switch is a binary action (on/off), and doing it twice cancels it out. This is exactly what XOR does! `A ^ 1` flips the bit `A`, and `(A ^ 1) ^ 1 = A`. So, the whole process can be thought of as XORing. The initial state is the single treasure bulb. Each operation XORs the grid state with the four-bulb pattern.

`FinalState = InitialState ^ Operation_1 ^ Operation_2 ^ ...`

We need to find a 'magic spell' (a function) that, when applied to the four bulbs in any operation, always results in zero. If we find such a spell, the total 'magic value' of all lit bulbs will never change, because each operation adds zero to it! This means the 'magic value' of the initial single treasure bulb must be the same as the 'magic value' of all `n` final lit bulbs.

Let's try to find some magic spells, nya!

#### Magic Spell 1: The X-Coordinate Spell
Let's just take the x-coordinate of each bulb and XOR them all together. For one operation at `(x, y)`, the four x-coordinates are `x`, `x`, `x+1`, `x+1`.
Let's XOR them: `x ^ x ^ (x+1) ^ (x+1)`.
We know that `A ^ A = 0`. So, `x ^ x` is `0`, and `(x+1) ^ (x+1)` is `0`.
The total XOR sum is `0 ^ 0 = 0`!
It works! This means the XOR sum of the x-coordinates of all lit bulbs is an **invariant**.

So, if the treasure was at `(s, t)`, the initial XOR sum of x-coordinates is just `s`.
After all operations, with `n` bulbs at `(x_1, y_1), ..., (x_n, y_n)`, the final XOR sum is `x_1 ^ x_2 ^ ... ^ x_n`.
Since the value is invariant:
`s = x_1 ^ x_2 ^ ... ^ x_n`
Yay! We found the x-coordinate of the treasure, `s`! That was easy, wasn't it? üò∏

#### Magic Spell 2: The Sum Spell
Finding `t` is a bit more work. Let's try another spell. What if we use the sum of coordinates, `x+y`?
For one operation at `(x, y)`, the four `x+y` values are:
1.  `x + y`
2.  `x + (y+1) = x+y+1`
3.  `(x+1) + (y-1) = x+y`
4.  `(x+1) + y = x+y+1`
Let's XOR these sums together: `(x+y) ^ (x+y+1) ^ (x+y) ^ (x+y+1)`.
Again, using `A ^ A = 0`, we have `((x+y) ^ (x+y)) ^ ((x+y+1) ^ (x+y+1)) = 0 ^ 0 = 0`.
Purrfect! The XOR sum of `(x_i + y_i)` for all lit bulbs is also an **invariant**!

So, for the treasure at `(s, t)`, the initial value of this invariant is `s + t`.
For the `n` final bulbs, the final value is `(x_1+y_1) ^ (x_2+y_2) ^ ... ^ (x_n+y_n)`.
Therefore:
`s + t = (x_1+y_1) ^ (x_2+y_2) ^ ... ^ (x_n+y_n)`

#### Putting It All Together
Now we have a system of two equations, nya~
Let `XR = x_1 ^ x_2 ^ ... ^ x_n`.
Let `XYS = (x_1+y_1) ^ (x_2+y_2) ^ ... ^ (x_n+y_n)`.

1.  `s = XR`
2.  `s + t = XYS`

From the first equation, we have `s`. We can plug this into the second equation (which uses regular addition, not XOR!).
`XR + t = XYS`
So, `t = XYS - XR`.

And that's it! The treasure is hidden at `(s, t) = (XR, XYS - XR)`. We just need to loop through the `n` given points, calculate `XR` and `XYS`, and then find `s` and `t`. Meow-velous!

### È¢òËß£ (Solution Code)

Here is a simple and clean C++ implementation of our plan, nya~. It's so elegant, it's almost poetic!

```cpp
#include <iostream>

// Using the standard namespace to keep things tidy, mew!
using namespace std;

int main() {
    // These lines make input/output faster, so our program runs like a cheetah!
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    int t;
    cin >> t; // Read the number of test cases
    while (t--) {
        int n;
        cin >> n; // Read the number of lit bulbs

        // 'xr' will store the XOR sum of all x-coordinates. This gives us 's'.
        long long xr = 0; 
        // 'xs' will store the XOR sum of all (x+y). This gives us 's+t'.
        long long xs = 0; 

        for (int i = 0; i < n; i++) {
            long long x, y;
            cin >> x >> y;
            // Apply our magic spells!
            xr ^= x;
            xs ^= (x + y);
        }

        // According to our logic:
        // The treasure's x-coordinate 's' is 'xr'.
        // The treasure's y-coordinate 't' is 'xs' - 'xr'.
        cout << xr << " " << (xs - xr) << "\n";
    }

    return 0;
}
```

### Áü•ËØÜÁÇπ (Knowledge Points)

Every good puzzle teaches us something new! Here are the key ideas we used, Master.

1.  **‰ΩçËøêÁÆó (Bitwise Operations), especially XOR (`^`)**
    XOR is our best friend in this problem, nya~. It has some nya-gical properties:
    *   **`A ^ A = 0`**: Anything XORed with itself is zero. This is why applying an operation twice cancels it out.
    *   **`A ^ 0 = A`**: XORing with zero doesn't change the value.
    *   **Commutative & Associative**: `A ^ B = B ^ A` and `(A ^ B) ^ C = A ^ (B ^ C)`. This means the order in which we XOR things doesn't matter, which is why we could just loop through the `n` points and accumulate the XOR sum.
    
    These properties make XOR perfect for problems about flipping states or anything that can be modeled as on/off.

2.  **‰∏çÂèòÈáè (Invariants)**
    This is the heart of the solution! An invariant is a quantity or property that does not change when we apply the allowed operations. Finding an invariant simplifies a complex, dynamic problem into a static one.
    
    In our case, the operations were designed in a very specific way. We hunted for properties that were 'zeroed out' by the operation. We found two:
    *   The XOR sum of all `x` coordinates.
    *   The XOR sum of all `(x+y)` values.
    
    By realizing these values must be the same for the initial state (one bulb) and the final state (`n` bulbs), we could set up equations to solve for the unknown `(s, t)`. Whenever you see a problem with a set of operations, always keep an eye out for potential invariants. It's like finding a secret shortcut, mew!

And that's how we solve it! With a bit of logic and a sprinkle of XOR magic, we found the treasure. Good job, Master! Now, how about some fish as a reward? üêü