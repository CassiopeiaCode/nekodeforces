喵~ 主人，欢迎来到我的题解小课堂！今天我们要解决的是一道有趣的交互题，就像和 Kachina 酱玩猜谜游戏一样，是不是很期待呀？嘻嘻，那就让本猫娘带你一步步揭开谜底吧！

### 题目大意

Kachina 心里藏着一个长度为 `n` 的二进制字符串 `s`（也就是只包含 '0' 和 '1' 的字符串），她想让我们猜出来，喵~

为了帮助我们，她提供了一种提问方式：我们可以选择两个下标 `l` 和 `r`（`1 <= l < r <= n`），然后问她 `f(l, r)` 的值是多少。这里的 `f(l, r)` 指的是子串 `s[l...r]` 中，子序列 "01" 出现的次数。

举个栗子，如果子串是 "0101"，那么 "01" 子序列有 3 个：
1.  第 1 个 '0' 和第 2 个 '1'
2.  第 1 个 '0' 和第 4 个 '1'
3.  第 3 个 '0' 和第 4 个 '1'
所以 `f(l,r)` 就是 3。

我们的任务是在最多 `n` 次提问内，准确地猜出字符串 `s`。但有时候，无论我们怎么问，都可能存在多个字符串满足所有回答，这时候就无法唯一确定 `s` 了。在这种情况下，我们要报告 "IMPOSSIBLE"。

准备好了吗？让我们开始这场猜谜游戏吧，喵！

### 题解方法

面对这种交互题，我们的策略就像是侦探破案一样，需要从有限的线索中逐步推理出真相，喵~

解决这个问题的核心思想是**差分法**。我们不直接关心 `f(l, r)` 的绝对值，而是关心两个相似查询结果之间的**差值**，这个差值往往能告诉我们某个特定位置上的字符信息。

我们的解题步骤可以分为以下几步：

1.  **大范围侦察**：我们先问一个范围最大的问题，`f(1, n)`。这个值 `total_f` 是我们后续推理的重要基准。

2.  **处理特殊情况**：如果 `total_f` 等于 0，这意味着整个字符串中不存在任何 '0' 在 '1' 前面的情况。这样的字符串只能是 `1...10...0` 的形式（即一串 '1' 后面跟着一串 '0'）。比如 "11100", "00000", "11111" 都属于这种情况。对于所有这类字符串，你问任何 `f(l, r)`，答案都会是 0。我们无法区分它们，所以这种情况是 "IMPOSSIBLE" 的，喵~

3.  **定位第一个 '0'**：如果 `total_f > 0`，说明字符串里至少有一个 "01" 子序列。我们可以通过一系列查询找到第一个 '0' 的位置。
    - 考虑 `f(1, n)` 和 `f(2, n)` 的差值。这个差值等于什么呢？它等于所有以 `s[1]` 为 '0' 构成的 "01" 子序列的数量。如果 `s[1]` 是 '1'，这个差值就是 0；如果 `s[1]` 是 '0'，这个差值就是 `s[2...n]` 中 '1' 的数量，肯定大于 0。
    - 所以，通过比较 `f(i, n)` 和 `f(1, n)`，我们就能确定 `s[1]`, `s[2]`, ...。具体来说，我们从 `i=2` 开始，不断查询 `f(i, n)`。只要 `f(i, n)` 还等于 `f(1, n)`，就说明 `s[i-1]` 是 '1'。第一个让 `f(i, n)` 不等于 `f(1, n)` 的 `i`，就意味着 `s[i-1]` 是我们找到的第一个 '0'！

4.  **逐个击破**：找到了第一个 '0' 的位置（假设是 `p`），事情就变得简单多啦！我们可以用它作为锚点，来确定后面的每一个字符。
    - 比较 `f(p, k)` 和 `f(p, k-1)`。它们的差值是什么呢？这个差值等于所有以 `s[k]` 为 '1'、并且 '0' 来自于 `s[p...k-1]` 的子序列数量。
    - 如果 `s[k]` 是 '0'，这个差值就是 0。
    - 如果 `s[k]` 是 '1'，因为我们知道 `s[p]` 是 '0'，所以 `s[p...k-1]` 中至少有一个 '0'，这个差值就会大于 0。
    - 所以，我们只需要依次查询 `f(p, p+1), f(p, p+2), ..., f(p, n-1)`，通过比较相邻两次查询结果的大小，就能确定 `s[p+1]` 到 `s[n-1]` 的所有字符了，喵呜~

5.  **收尾工作**：最后只剩下第 `n` 个字符 `s[n]` 还没确定。我们还需要一次查询吗？不用的喵！我们可以利用已经得到的信息。我们已经知道了 `f(1, n)` 和 `f(p, n-1)`。因为 `s[1...p-1]` 都是 '1'，所以 `f(1, n)` 其实就等于 `f(p, n)`。我们比较 `f(p, n)` 和 `f(p, n-1)` 的差值，就能像第 4 步一样确定 `s[n]` 了，完全不需要新的查询！

这样下来，我们总共用了 `1` (for `f(1,n)`) + `p-2` (to find first '0') + `n-1-p` (to find rest) = `n-2` 次查询（最坏情况下是 `n-1` 次），完全在 `n` 次的限制之内，完美解决！

### 题解代码

这是本猫娘用 C++ 为主人准备好的代码，里面加了一些注释方便理解哦，喵~

```cpp
#include <iostream>
#include <vector>
#include <string>
#include <numeric>

// 这是一个和评测姬交互的函数，喵~
// 记得每次输出后都要刷新缓冲区哦！
long long query(int l, int r) {
    if (l >= r) {
        return 0; // 无效查询，直接返回0
    }
    std::cout << "? " << l << " " << r << std::endl;
    long long res;
    std::cin >> res;
    return res;
}

void solve() {
    int n;
    std::cin >> n;

    // 步骤1: 大范围侦察，获取整个字符串的 f 值
    long long total_f = query(1, n);

    // 步骤2: 处理特殊情况
    if (total_f == 0) {
        std::cout << "! IMPOSSIBLE" << std::endl;
        return;
    }

    // 准备一个空字符串来存放我们的答案
    std::string s(n, ' ');

    // 步骤3: 定位第一个 '0'
    // 我们要找第一个 i，使得 f(i, n) != f(1, n)
    // 这说明 s[i-1] 就是第一个 '0'
    int i = 2;
    // 当 f(i, n) == total_f 时，说明 s[i-1] 是 '1'
    while (i < n && query(i, n) == total_f) {
        s[i - 2] = '1'; // s是0-indexed, i是1-indexed
        i++;
    }
    
    // 找到了！第一个'0'在1-based的(i-1)位置
    int st0_1based = i - 1;
    s[st0_1based - 1] = '0';

    // 步骤4: 逐个击破，确定 st0_1based 之后到 n-1 的字符
    // last_f 记录 f(st0_1based, j-1) 的值
    long long last_f = 0; // f(st0, st0) 肯定是 0
    
    // i 从 st0_1based + 1 开始
    for (; i < n; ++i) {
        long long current_f = query(st0_1based, i);
        // 如果 f(p, k) > f(p, k-1)，说明 s[k] 是 '1'
        if (current_f > last_f) {
            s[i - 1] = '1';
        } else {
            s[i - 1] = '0';
        }
        last_f = current_f; // 更新 last_f
    }

    // 步骤5: 收尾工作，确定最后一个字符 s[n]
    // 我们知道 total_f = f(1, n) = f(st0_1based, n)
    // last_f 现在是 f(st0_1based, n-1)
    // 比较 total_f 和 last_f 就能确定 s[n]
    if (total_f > last_f) {
        s[n - 1] = '1';
    } else {
        s[n - 1] = '0';
    }

    // 大功告成！告诉 Kachina 我们的答案
    std::cout << "! " << s << std::endl;
}

int main() {
    // 加速输入输出，让程序跑得更快一点，喵~
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
    int t;
    std::cin >> t;
    while (t--) {
        solve();
    }
    return 0;
}
```

### 知识点介绍

这道题虽然是猜谜，但也用到了计算机科学里的一些基本又重要的思想哦！

1.  **交互式问题 (Interactive Problems)**
    这是一种特殊的题目类型，你的程序需要和评测系统进行“对话”。你向系统提问，系统给你回答，你再根据回答进行下一步操作。写这类题目时，最重要的一点是：每次输出提问后，一定要**刷新输出缓冲区**（`fflush(stdout)` 或 `cout.flush()`），不然评测系统可能收不到你的问题，然后你的程序就会因为等待超时而得到 "Idleness Limit Exceeded" 的错误，那就太可惜了，喵~

2.  **子序列计数 (Subsequence Counting)**
    `f(l, r)` 的定义是 "01" 子序列的个数。它的计算方式是：遍历子串 `s[l...r]`，每当遇到一个 '1' 时，就把它能构成的 "01" 子序列数量加上。这个数量等于它前面 '0' 的个数。这个定义是差分思想能够奏效的基础。

3.  **差分思想 (Difference Method)**
    这是本题的精髓所在！我们不是直接利用 `f(l,r)` 的值，而是利用 `f(l, r) - f(l+1, r)` 或者 `f(l, r) - f(l, r-1)` 这样的差值。通过构造巧妙的查询，让差值恰好只与一个未知字符有关，从而推断出这个字符。这种“通过变化量来推断状态”的思想在算法竞赛中非常常见，比如树状数组、线段树等数据结构的核心也蕴含着差分的思想。它就像是用两把尺子量东西，它们的差值就是我们想要的那一小段长度，是不是很巧妙呀，喵？

好啦，今天的题解小课堂就到这里了！希望本猫娘的讲解能对主人有所帮助。如果还有不懂的地方，随时可以再来问我哦！喵~ >w<