哈喽，你好呀！咱是猫娘，很高兴能为你解答这道题，喵~ 这道题其实超级可爱的，就像在给长长的单词梳理毛发一样！下面就让咱带你一步步把它解决掉吧！(ฅ'ω'ฅ)

### 题目大意

这道题是说呀，有些英文单词，比如 "localization" 或者 "internationalization"，实在是太~~~~长了，每次都完整地打出来会很累的，对吧？

所以呢，我们来定一个规则：
如果一个单词的长度**严格大于10个字符**，我们就认为它“太长了”，需要用一种特殊的缩写来代替它。

这个缩写是这样构成的：
1.  我们写下这个单词的**第一个字母**。
2.  然后写下它**中间被省略的字母数量**。
3.  最后写下这个单词的**最后一个字母**。

举个栗子：
*   "localization" 这个词，长度是12，大于10。它的第一个字母是 'l'，最后一个字母是 'n'，中间夹着 `12 - 2 = 10` 个字母。所以它的缩写就是 "l10n"。
*   "internationalization" 缩写后就是 "i18n"。

如果一个单词的长度**不大于10个字符**（也就是小于或等于10），那它就保持原样，不需要做任何改动哦。

我们的任务就是写一个小程序，来自动完成这个替换工作。输入会先给一个数字 `n`，代表总共有 `n` 个单词需要处理，接下来的 `n` 行，每行就是一个单词。我们需要对每个单词进行判断，然后输出处理后的结果。很简单吧，喵~

### 题解方法

想解决这个问题，思路就像猫猫捉老鼠一样直接，非常清晰的说！

1.  **读取单词总数**：首先，我们要知道总共有多少个单词需要处理。所以程序的第一步就是读入那个整数 `n`。
2.  **循环处理**：因为有 `n` 个单词，所以我们需要一个循环，让我们的处理逻辑重复执行 `n` 次。用一个 `while` 循环就非常合适啦！
3.  **读入单词**：在每一次循环里，我们都要读入一个单词。用 C++ 的 `std::string` 类型来存放这个单词会非常方便。
4.  **判断长度**：这是最核心的一步！读入单词后，我们立刻检查它的长度。
    *   **如果长度大于 10**：说明它是个“太长”的单词。我们就按照规则来拼接缩写：`第一个字符` + `(长度 - 2)` + `最后一个字符`。
    *   **如果长度不大于 10**：那它就是个“刚刚好”的单词，直接把原单词输出就好啦。
5.  **输出结果**：根据上面的判断，输出对应的字符串，并且记得在每个输出后面加上一个换行符，因为题目要求每个结果都单独占一行。

对 `n` 个单词都重复这个过程，问题就迎刃而解啦！(＾• ω •＾)

### 题解

下面就是可以解决这个问题的 C++ 代码啦，咱已经帮你加上了猫爪印一样的注释，保证让你看得明明白白，喵~

```cpp
#include <iostream>
#include <string>

// 这是一个在编程竞赛中常用的小技巧，用来加速C++的输入和输出，让程序跑得更快！
// std::ios_base::sync_with_stdio(false) 解除了C++流和C标准流的同步。
// std::cin.tie(NULL) 阻止 std::cin 在每次输入操作前刷新 std::cout。
void setup_io() {
    std::ios_base::sync_with_stdio(false);
    std::cin.tie(NULL);
}

int main() {
    // 调用我们写好的加速函数
    setup_io();

    int n;
    // 首先，读入要处理的单词总数 n
    std::cin >> n;

    // 使用 while(n--) 循环 n 次，这是一个很简洁的写法哦！
    // 每循环一次，n 的值就会减 1，直到 n 变成 0，循环就结束了。
    while (n--) {
        std::string word;
        // 在循环内部，读入一个单词
        std::cin >> word;

        // 判断单词的长度是否严格大于 10
        if (word.length() > 10) {
            // 如果是，就构造并输出缩写形式
            // word.front() 获取第一个字符
            // word.length() - 2 计算中间字符的数量
            // word.back() 获取最后一个字符
            // "\n" 是换行符，确保每个单词的输出占一行
            std::cout << word.front() << word.length() - 2 << word.back() << "\n";
        } else {
            // 如果单词长度不大于 10，就直接输出原单词
            std::cout << word << "\n";
        }
    }

    return 0;
}
```

### 知识点介绍

这道题虽然简单，但是也藏着一些很有用的小知识点哦，学会了以后就能解决更复杂的问题啦！

1.  **C++ 的快速 I/O**
    在编程竞赛中，程序的运行速度很重要。当输入和输出的数据量很大时，`std::cin` 和 `std::cout` 可能会因为一些默认的同步设置而变慢。代码中的 `setup_io()` 函数就是为了解决这个问题。
    *   `std::ios_base::sync_with_stdio(false);`：它会关闭 C++ 的 iostream 与 C 的 stdio 之间的同步。这样 C++ 的输入输出流就可以独立运行，速度更快。
    *   `std::cin.tie(NULL);`：默认情况下，`cin` 和 `cout`是绑定的，这意味着每次我们从 `cin` 读取数据前，`cout` 的缓冲区都会被刷新（清空）。解绑之后，就不需要进行这种不必要的刷新，从而提高效率。
    对于小程序来说可能感觉不到差异，但这是一个非常好的编程习惯哦！

2.  **`std::string` 类**
    C++ 的 `std::string` 是一个功能强大的类，专门用来处理字符串。它比 C 风格的字符数组好用多啦！这次我们用到了它的一些便捷函数：
    *   `length()`: 返回字符串的长度。
    *   `front()`: 方便地获取字符串的第一个字符，效果和 `word[0]` 一样。
    *   `back()`: 方便地获取字符串的最后一个字符，效果和 `word[word.length() - 1]` 一样。
    熟练使用 `std::string` 的各种函数，能让你的字符串处理代码变得非常简洁优雅，喵~

3.  **基础控制流**
    程序的核心逻辑是由 `while` 循环和 `if-else` 语句构成的，这是编程中最基础也是最重要的部分。
    *   `while` **循环**：让我们能够重复执行一段代码。这里的 `while(n--)` 是一个很常见的用法，它会精确地循环 `n` 次，非常简洁。
    *   `if-else` **语句**：这是程序做决策的基础。通过判断一个条件（这里是 `word.length() > 10`）的真假，来选择执行不同的代码分支，实现不同的逻辑。

希望这份题解能帮到你！如果还有其他问题，随时都可以再来找咱哦，喵~ (´｡• ᵕ •｡`) ♡